<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>The Island</title>
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
            background-image: url(assets/starrysky.png);
            background-size: cover;
            
        }
        p{
            color:white;
            font-family: arial;
            text-align:center;
        }
       
    </style>
</head>
<body>
    <p>banana Press F for Fullscreen.</p>
<script type="text/javascript">
/*******************
**Global Variables**
*******************/
var game = new Phaser.Game(960, 960, Phaser.AUTO,'', { preload: preload, create: create, update: update });
var SCALE = 32;
var gameMode = 0;
var timer;
var text;
var NARRATION1 = "Welcome to the middle of nowhere! Once upon a time, some volcanoes erupted and created an island."
var narration1 = "";
var narText;
var speechBubble;
var textCount = 0;
var narrationCount = 0;
var counter = 0;
var eruptBar;
var volcanoes = [];
var fsButton;
var islandMap;
var layer1;
var platforms;
var player;
var phase1Time = 2; //number of seconds to build island
var cursors;
var click = false;
var lavaFlows = [];
var lavaCount; //Used for preventing multiple eruptions at once
var lavaIndex = 0; //keep track of lava in array
var lavaSpawned = false; //register only one click at a time
var lavaSheet;
var windArray = [];
var windIndex = 0;
var windTimerBuild;
var windTimerUse;
var windButton;
var windCount;
var windTime=5;
var debrisArray = [];
var debrisIndex = 0;
var treeArray = [];
var treeIndex = 0;
var trashArray = [];
var trashIndex = 0;
var mapArray = createArray(30,30);
var debug;
var islandSize = 0;
var narrator;

function preload() {
    

    game.load.image('ground', 'assets/32/grasstile.png');
    game.load.image('mountain','assets/32/mountain.png');
    game.load.image('tiles','assets/32/island.png');
    game.load.image('seaVolcano','assets/32/volcano.png');
    game.load.image('landVolcano','assets/32/volcanograss.png');
    game.load.spritesheet('lavaflow','assets/32/lavaflow.png',32,32);
    game.load.image('eruptbar','assets/eruptBar.png');
    game.load.image('fire','assets/fire.png');
    game.load.image('narrator','assets/oldman.png');
    game.load.image('speech','assets/speechbubble.png');
    game.load.image('ground2', 'assets/32/grasstile2.png');
    game.load.image('beachLeft', 'assets/32/beachLeft.png');
    game.load.image('beachUp', 'assets/32/beachUp.png');
    game.load.image('beachRight', 'assets/32/beachRight.png');
    game.load.image('beachDown', 'assets/32/beachDown.png');
    game.load.image('beachLeftUp', 'assets/32/beachLeftUp.png');
    game.load.image('beachUpRight', 'assets/32/beachUpRight.png');
    game.load.image('beachRightDown', 'assets/32/beachRightDown.png');
    game.load.image('beachDownLeft', 'assets/32/beachDownLeft.png');
    game.load.image('beachUpDown', 'assets/32/beachUpDown.png');
    game.load.image('beachLeftRight', 'assets/32/beachLeftRight.png');
    game.load.image('beachDownLeftUp', 'assets/32/beachDownLeftUp.png');
    game.load.image('beachLeftUpRight', 'assets/32/beachLeftUpRight.png');
    game.load.image('beachUpRightDown', 'assets/32/beachUpRightDown.png');
    game.load.image('beachRightDownLeft', 'assets/32/beachRightDownLeft.png');
    game.load.image('coconut','assets/32/coconut.png');
    game.load.image('trash','assets/32/coconut.png');
    game.load.image('windLeft','assets/32/windLeft.png');
    game.load.image('windUp','assets/32/windUp.png');
    game.load.image('windRight','assets/32/windRight.png');
    game.load.image('windDown','assets/32/windDown.png');
    game.load.image('windButton','assets/32/windButton.png');
    game.load.spritesheet('wind','assets/32/wind.png',32,32);
}


    
function create() {
    
   
    /******************8
   Full Screen Options
   ********************/
    //options for fullscreen
    // Stretch to fill
    //game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;

    // Keep original size
    // game.scale.fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE;

    // Maintain aspect ratio
     game.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;
    
    //fullscreen hotkey
    fullscreenHotkey = game.input.keyboard.addKey(Phaser.Keyboard.F);
    fullscreenHotkey.onDown.add(gofull, this);
    
    /******************8
   Setting up the TileMap
   ********************/
    
    //  Create some map data dynamically
    //  Map size is 30x30 tiles
    var data = '';
    
    for (var y = 0; y < 30; y++)
    {
        for (var x = 0; x < 30; x++)
        {
            data += "0";
            mapArray[x][y] = "0";
            if (x < 29)
            {
                data += ',';
            }
        }

        if (y < 29)
        {
            data += "\n";
        }
    }
    
    //  Add data to the cache
    game.cache.addTilemap('dynamicMap', null, data, Phaser.Tilemap.CSV);
    
    //  Create our map (the 16x16 is the tile size)
    map = game.add.tilemap('dynamicMap', SCALE, SCALE);
    
    //  'tiles' = cache image key, 16x16 = tile size
    map.addTilesetImage('tiles', 'tiles', SCALE, SCALE);
    
    //  0 is important
    layer = map.createLayer(0);
    
    //resize the world
    layer.resizeWorld();
  
    /******************8
   Physics
   ********************/
    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);

    
    
    
    //text = game.add.text(250, 16, '', { fill: '#ffffff' });
    
    intro();
}
function gofull() {

    game.scale.startFullScreen();

}

function update() {
    if (gameMode == 1){moveFire();}
    
    if (game.input.activePointer.isUp && click){
        click = false;
        if(gameMode == 0 || gameMode == 2){
            updateText(1);
        }
        if(gameMode ==1 && phase1Time > 0){erupt();}
    }
    if (game.input.activePointer.isDown){
        click = true;
    }
    
    lavaFlows.forEach(function(element){
        element.update();
    })
    
    if (gameMode == 4){
        windArray.forEach(function(element){
            element.update();
        })
        debrisArray.forEach(function(element){
            element.update();
        })
    }
    this.game.scale.pageAlignHorizontally = true;this.game.scale.pageAlignVertically = true;this.game.scale.refresh();
    //changeMap(15,15,"5");
    //drawMap();

}

    /////////////////////////////////
//////////////NARRATOR LOGIC////////////
    ////////////////////////////////
function intro(){
    
    timer = game.time.create(false);
    timer.loop(50, updateText, this);
    speechBubble = game.add.sprite(10,100,'speech');
    speechBubble.scale.setTo(1,.5);
    narrator = game.add.sprite(700,560,'narrator');
    narrator.scale.setTo(.5,.5);
    text = game.add.text(80,160,"",{ font: "50px Arial", fill: '#000000', wordWrap: true, wordWrapWidth: 850 });
    timer.start();
}
function updateText(signal){
    if(!(narration1 == NARRATION1)){narration1 = narration1 + NARRATION1.substr(textCount,1);textCount += 1;}
    speechBubble.bringToTop();
    game.world.bringToTop(text);
    if(narration1 == NARRATION1){
        //Done with text
        if (signal == 1 && narrationCount == 0){
            if (gameMode == 0){
                NARRATION1 = "As the lava flowed, it cooled over the water and freshly formed land.";
            }
            
            narration1 = "";
            textCount = 0;
            narrationCount = 1;
        }else if (signal == 1 && narrationCount == 1 && gameMode == 0){
            NARRATION1 = "The more intense the eruptions, the higher chance the lava would cool upon the ground forming mountains.";
            narration1 = "";
            textCount = 0;
            narrationCount = 2;
        }else if(signal == 1 && narrationCount == 2 && gameMode == 0){
            NARRATION1 = "Intense eruptions could form the island quicker, but the mountains they left behind inhibit plant growth!";
            narration1 = "";
            textCount = 0;
            narrationCount =3 ;
        }else if(narrationCount == 3){narrationCount = 4;}
        if((signal == 1 && narrationCount == 4) || (signal == 1 && narrationCount == 1 && gameMode == 2)){
            timer.destroy();
            narrator.destroy();
            speechBubble.destroy();
            text.destroy();
            NARRATION1 = "";
            narration1 = "";
            textCount = 0;
            text = game.add.text(5,5,"",{ font: "50px Arial", fill: '#ffffff', wordWrap: true, wordWrapWidth: 850 });
            if (gameMode == 0){islandCreation();}
            else if(gameMode==2){enterPhase2();}
        }
    }else if(signal == 1){
        narration1 = NARRATION1;
        //timer.destroy();
    }
    
    text.setText(narration1);
    
}
    /////////////////////////////////
//////////////END NARRATOR LOGIC////////////
    ////////////////////////////////
    
        /////////////////////////////////
//////////////PHASE 1 LOGIC////////////
    ////////////////////////////////
    
function islandCreation(){
    //Setup pause timer for delay before loading game
    text.setText("Time Remaining: " + phase1Time);
    timer = game.time.create(true);
    timer.loop(500, pause, this);
    timer.start();
    
}

function pause(){
    //slight delay to allow game to load after intro
    gameMode = 1;
    
    volcanoes[0] = game.add.sprite(448,448,'seaVolcano');
    volcanoes[1] = game.add.sprite(480,448,'seaVolcano');
    volcanoes[2] = game.add.sprite(448,480,'seaVolcano');
    volcanoes[3] = game.add.sprite(480,480,'seaVolcano');
    //Set Volcano Tiles in Array
    mapArray[14][14] = 2;
    mapArray[15][14] = 2;
    mapArray[14][15] = 2;
    mapArray[15][15] = 2;
    eruptBar = game.add.sprite(0,920,'eruptbar');
    eruptBar.scale.setTo(2,2);
    fire = game.add.sprite(6,900,'fire');
    fire.scale.setTo(2,2);
    timer.destroy();
    timer = game.time.create(true);
    timer.loop(1000, phase1Timer, this);
    timer.start();
}
function phase1Timer(){
    //Keeps track of time remaining in phase 1 and handles transition to phase 2
    phase1Time -= 1;
    if (phase1Time <= 0 && lavaCount == 0){ //make sure no lava is still flowing before entering phase 2
        //Begin Phase 2 Here
        gameMode = 2;
        NARRATION1 = "As the lava cooled, the winds picked up, pulling debris towards the newly formed land.";
        eruptBar.destroy();
        fire.destroy();
        timer.destroy();
        text.destroy();
        intro();
    }
    if(phase1Time >= 0){text.setText("Time Remaining: " + phase1Time);}

}

function erupt(){
    //Erupt volcanoes based on fire location when clicked
    var picked = []; //gets assigned and passed directly to lava start location with lavaStart function
    if (!lavaSpawned){
    if(fire.x >= 3 && fire.x <= 240){
        lavaCount = 1;
        lavaFlows[lavaIndex] = new LavaFlow(lavaIndex,picked[0]=lavaStart(picked),1,game) ;
        lavaFlows[lavaIndex].checkLava();
        lavaIndex +=1;
    }else if(fire.x >= 241 && fire.x <= 660){
        lavaCount = 2;
        lavaFlows[lavaIndex] = new LavaFlow(lavaIndex,picked[0]=lavaStart(picked),2,game) ;
        lavaFlows[lavaIndex].checkLava();
        lavaIndex +=1;
        lavaFlows[lavaIndex] = new LavaFlow(lavaIndex,picked[1]=lavaStart(picked),2,game) ;
        lavaFlows[lavaIndex].checkLava();
        lavaIndex +=1;
    }else if(fire.x >= 661){
        lavaCount = 3;
        lavaFlows[lavaIndex] = new LavaFlow(lavaIndex,picked[0]=lavaStart(picked),3,game) ;
        lavaFlows[lavaIndex].checkLava();
        lavaIndex +=1;
        lavaFlows[lavaIndex] = new LavaFlow(lavaIndex,picked[1]=lavaStart(picked),3,game) ;
        lavaFlows[lavaIndex].checkLava();
        lavaIndex +=1;
        lavaFlows[lavaIndex] = new LavaFlow(lavaIndex,picked[2]=lavaStart(picked),3,game) ;
        lavaFlows[lavaIndex].checkLava();
        lavaIndex +=1;
    }
        
    
    }
    lavaSpawned = true;
}
function moveFire(){
    //Moves fire sprite back and forth along erupt bar
    if (fire.x == 896)
        {
            game.add.tween(fire).to({x: 6}, 1000 , Phaser.Easing.Out, true);

        }
    else if (fire.x == 6)
        {
            game.add.tween(fire).to({x: 896}, 1000 , Phaser.Easing.Out, true);

        }
}
function lavaStart(lavas){
    //Set unique lava start location so they can't spawn on same volcano
    var picked;
    var start;
    do{
        picked = false;
        start = game.rnd.integerInRange(1, 4);
        lavas.forEach(function(element){
            if(element == start){picked = true;}
        }) 
    } while(picked);
    
    return start;
}
LavaFlow = function (index, start, intensity, game){
    //Object constructor for lava
    var x, y;
    
    this.index = index; //used to add and remove from lavaFlows array
    this.game = game;
    this.start = start; //which volcano the lava starts from
    this.speed = 0; //how quickly the lava moves, inverse values: higher = slower
    this.intensity = intensity; //based on the eruption intensity when created, higher intensity gives higher chance to spawn mountains
    this.direction = "flowDown";
    
    //create land under volcanoes when lava is spawned on top of them
    if (start == 1){
        x=448;y=448;
        volcanoes[0] = game.add.sprite(x, y, 'landVolcano');
    }else if (start == 2){
        x=480;y=448;
        volcanoes[1] = game.add.sprite(x, y, 'landVolcano');
    }else if (start == 3){
        x=448;y=480;
        volcanoes[2] = game.add.sprite(x, y, 'landVolcano');
    }else if (start == 4){
        x=480;y=480;
        volcanoes[3] = game.add.sprite(x, y, 'landVolcano');}
    this.alive = true;
    
    //Create the sprite to display and animations
    this.lava = game.add.sprite(x, y, 'lavaflow');
    this.lava.animations.add('flowDown', [0,1,2], 6);
    this.lava.animations.add('flowLeft',[3,4,5],6);
    this.lava.animations.add('flowUp',[6,7,8],6);
    this.lava.animations.add('flowRight',[9,10,11],6);
    
    this.update = function(){
        this.lava.bringToTop(); //Ensures lava stays over land created
        //Change animation based on direction
        if (this.direction == "flowLeft"){this.lava.animations.play('flowLeft');}
        else if (this.direction == "flowUp"){this.lava.animations.play('flowUp');}
        else if (this.direction == "flowDown"){this.lava.animations.play('flowDown');}
        else if (this.direction == "flowRight"){this.lava.animations.play('flowRight');}
    }
    this.checkLava = function(){
        //Move lava in random direction based on starting location
        
        var x = this.lava.x;
        var y = this.lava.y;
        var dir;
        if (this.start == 1){ //Top Left
            dir = game.rnd.integerInRange(1,2);
            if (dir == 1){ //Move Left
                x -= SCALE;
                this.direction = "flowLeft";
            }
            else if(dir == 2){
                y -= SCALE;
                this.direction = "flowUp";
            } //Move Up
        }else if (this.start == 2){ //Top Right
            dir = game.rnd.integerInRange(1,2);
            if (dir == 1){
                x += SCALE;
                this.direction = "flowRight";
            } //Move Right
            else if(dir == 2){
                y -= SCALE;
                this.direction = "flowUp";
            } //Move Up
        }else if (this.start == 3){ //Bottom Left
            dir = game.rnd.integerInRange(1,2);
            if (dir == 1){
                x -= SCALE;
                this.direction = "flowLeft";
            } //Move Left
            else if(dir == 2){
                y += SCALE;
                this.direction = "flowDown";
            } //Move Down
        }else if (this.start == 4){ //Bottom Right
            dir = game.rnd.integerInRange(1,2);
            if (dir == 1){
                x += SCALE;
                this.direction = "flowRight";
            } //Move Right
            else if(dir == 2){
                y += SCALE
                this.direction = "flowDown";
            } //Move Down
        }
        
        //Move the lava, taking its speed into account
        var tween = this.game.add.tween(this.lava).to({x: x, y: y},500+this.speed, Phaser.Easing.Linear.None, true);
        //Call function this.move() when lava has finished moving
        tween.onComplete.add(this.move, this);
    }
    this.move = function(){
        //Move complete. Logic to determine what tile is under lava and where to go from there
        var tileX = this.lava.x /SCALE; //get array X from literal X
        var tileY = this.lava.y /SCALE; //get array Y from literal Y
        var mnt = game.rnd.integerInRange(1,100); //Random chance to create mountain
        
        //Increase chance of spawning mountain at higher intensity
        if(this.intensity == 2){mnt -= 5;}
        else if(this.intensity == 3){mnt -= 10;}
        if(mapArray[tileX][tileY] == 0){ //no ground
            checkTiles(tileX,tileY,"lava");
            
            islandSize +=1;
            this.destroy();
        
        } else if (mapArray[tileX][tileY] == 1){ //moved over land
            //Logic for creating mountains. The longer a lava is on land, the higher its speed and this the higher chance of creating a mountain
            if(this.speed >= 400 && mnt <= 10){
                mapArray[tileX][tileY] = 3;
                
                game.add.sprite(this.lava.x,this.lava.y,'mountain');
                this.destroy();
            } else if (this.speed >= 300 && mnt <=5){
                mapArray[tileX][tileY] = 3;
                
                game.add.sprite(this.lava.x,this.lava.y,'mountain');
                this.destroy();
            } else if (this.speed >= 200 && mnt <=3){
                mapArray[tileX][tileY] = 3;
                
                game.add.sprite(this.lava.x,this.lava.y,'mountain');
                this.destroy();
            } else if (this.speed >= 100 && mnt <=1){
                mapArray[tileX][tileY] = 3;
                
                game.add.sprite(this.lava.x,this.lava.y,'mountain');
                this.destroy();
            }else {this.checkLava();this.speed+= game.rnd.integerInRange(50,150);}
            
            
        }else if(mapArray[tileX][tileY] == 3){//if lava flows over mountain, slow it down
            this.speed += 200;
            this.checkLava();
            this.speed += game.rnd.integerInRange(50,150);
        }else { //if no mountain is created, and didn't hit water, slow lava and move again
            this.checkLava();
            this.speed+= game.rnd.integerInRange(50,150);}
        //Logic for darkening lava as it slows
        if (this.speed >= 300){this.lava.tint = 0x808080;}
        else if(this.speed >= 200){this.lava.tint = 0xA9A9A9;}
        else if (this.speed >= 100){this.lava.tint = 0xBEBEBE;}
        else if (this.speed >= 0){this.lava.tint = 0xF5F5F5;}
    }
    this.destroy = function(){
        lavaFlows.splice(this.index, 1); //remove this object from the lavaFlows array
        this.lava.destroy(); //destroy the sprite so it no longer draws
        //Logic to handle whether new lava can be spawned yet
        lavaCount -= 1; 
        if (lavaCount == 0){
            lavaSpawned = false;
        }
    }

};

function checkTiles(x,y,source){
    //Build beaches based on adjacent tiles
    //mapArray[x][y]   = current tile
    //mapArray[x-1][y] = left tile
    //mapArray[x+1][y] = right tile
    //mapArray[x][y-1] = upper tile
    //mapArray[x][y+1] = lower tile
    //Array Values
    //0 = water, 1 = grass, 2 = volcano, 3 = mountain
    var water = 0; //used to check which tiles surrounding the current tile are water. incremented by a unique value for each direction such that no sums overlap
    if(mapArray[x-1][y] == 0){ water += 3} //add 3 if the tile left of this is water
    if(mapArray[x][y-1] == 0){ water += 11} //add 11 if the tile above this is water
    if(mapArray[x+1][y] == 0){ water += 17} //add 17 if the tile right of this is water
    if(mapArray[x][y+1] == 0){ water += 22} //add 22 if the tile below this is water
    if ((source == "grass" && mapArray[x][y] != 0 && mapArray[x][y] != 2 && mapArray[x][y] != 3) || source == "lava")
    {
        if (water == 0){
            plantGrass(x,y);
        }if (water == 3){
            game.add.sprite(x*SCALE,y*SCALE,"beachLeft");
            mapArray[x][y] = 1;
        }if (water == 11){
            game.add.sprite(x*SCALE,y*SCALE,"beachUp");
            mapArray[x][y] = 1;
        }if (water == 17){
            game.add.sprite(x*SCALE,y*SCALE,"beachRight");
            mapArray[x][y] = 1;
        }if (water == 22){
            game.add.sprite(x*SCALE,y*SCALE,"beachDown");
            mapArray[x][y] = 1;
        }if (water == 14){
            game.add.sprite(x*SCALE,y*SCALE,"beachLeftUp");
            mapArray[x][y] = 1;
        }if (water == 28){
            game.add.sprite(x*SCALE,y*SCALE,"beachUpRight");
            mapArray[x][y] = 1;
        }if (water == 39){
            game.add.sprite(x*SCALE,y*SCALE,"beachRightDown");
            mapArray[x][y] = 1;
        }if (water == 25){
            game.add.sprite(x*SCALE,y*SCALE,"beachDownLeft");
            mapArray[x][y] = 1;
        }if (water == 33){
            game.add.sprite(x*SCALE,y*SCALE,"beachUpDown");
            mapArray[x][y] = 1;
        }if (water == 20){
            game.add.sprite(x*SCALE,y*SCALE,"beachLeftRight");
            mapArray[x][y] = 1;
        }if (water == 31){
            game.add.sprite(x*SCALE,y*SCALE,"beachLeftUpRight");
            mapArray[x][y] = 1;
        }if (water == 50){
            game.add.sprite(x*SCALE,y*SCALE,"beachUpRightDown");
            mapArray[x][y] = 1;
        }if (water == 42){
            game.add.sprite(x*SCALE,y*SCALE,"beachRightDownLeft");
            mapArray[x][y] = 1;
        }if (water == 36){
            game.add.sprite(x*SCALE,y*SCALE,"beachDownLeftUp");
            mapArray[x][y] = 1;
        }
        //Once lava has created its beach, check the 4 tiles adjacent to update their beaches based on the newly formed land
        if (source != "grass"){
            checkTiles(x-1,y,"grass");
            checkTiles(x,y-1,"grass");
            checkTiles(x+1,y,"grass");
            checkTiles(x,y+1,"grass");
        }
    }
}
function plantGrass(x,y){
    //Create basic land if no water is surrounding the tile
    var ground = game.rnd.integerInRange(1,100);
    if (ground <=75){game.add.sprite(x*SCALE,y*SCALE,'ground');}
    else if (ground >=76){game.add.sprite(x*SCALE,y*SCALE,'ground2');}
    mapArray[x][y] = 1;
}
    /////////////////////////////////
//////////////END PHASE 1 LOGIC////////////
    ////////////////////////////////

    /////////////////////////////////
//////////////PHASE 2 LOGIC////////////
    ////////////////////////////////
function phase2Time(){
    windTime -= 1;
    if (windTime ==0){
        if (gameMode == 3){
            windBuild();
            windTime = 20;
        }
        else if (gameMode == 4){
            windUse();
            windTime = 5;
        }
    }
    
    phase2Text();
}
function enterPhase2(){
    
    gameMode = 3;
    windCount = 0;
    windButton = game.add.sprite(470,800,'windButton');
    windButton.inputEnabled = true;
    windButton.events.onInputDown.add(windClick,this);
    windButton.anchor.setTo(.5,.5);
    phase2Text();
    //windTimerBuild = game.time.create(false);
   // windTimerBuild.loop(windTime * 1000, windBuild, this);
    //windTimerBuild.start();
    timer = game.time.create(false);
    timer.loop(1000, phase2Time, this);
    timer.start();
}

function windBuild(){
    gameMode = 4;
   
    windButton.destroy();
    createWind();
    //windTimerUse = game.time.create(false);
    //windTimerUse.loop(windTime * 1000,windUse,this);
    //windTimerUse.start();
    //windTimerBuild.destroy();
}
    
function windUse(){
    windArray.forEach(function(element){
        element.destroy();
        element.wind.destroy();
    })
    windArray = [];
    windIndex = 0;
    gameMode = 3;
    windCount = 0;
    
    windButton = game.add.sprite(470,800,'windButton');
    windButton.inputEnabled = true;
    windButton.events.onInputDown.add(windClick,this);
    windButton.anchor.setTo(.5,.5);
    //windTimerBuild = game.time.create(false);
    //windTimerBuild.loop(windTime * 1000, windBuild, this);
    //windTimerBuild.start();
    //windTimerUse.destroy();
}

function windClick(){
    windCount += 1;
    var scale = 5
    if (windCount >= scale && windCount % scale == 0){
        scale = windCount /scale;
        windButton.scale.setTo(scale,scale);
        windButton.x -= scale;
        windButton.y -= scale;
    }
    
    
    
    phase2Text();
}

function createWind(){
    var rand = game.rnd.integerInRange(1,3);
    for(i=0; i<rand; i++){
        windArray[windIndex] = new Wind(windIndex,game);
        windIndex++;
    }
    for(i=0; i<windCount/3; i++){
        windArray[windIndex] = new Wind(windIndex,game);
        windIndex++;
    }
    rand = game.rnd.integerInRange(6,12);
    for(i=0;i<rand;i++){
        debrisArray[debrisIndex] = new Debris(debrisIndex,game);
        debrisArray[debrisIndex].move();
        debrisIndex++;
    }
}
    
function phase2Text(){
    if(gameMode == 3){
        text.setText("Time Remaining: " + windTime + " Wind Power: " + windCount);
    }else if(gameMode == 4){
        text.setText("Time Remaining: " + windTime);
    }
}
Wind = function (index, game){
    
    this.index = index;
    this.game = game;
    this.speed = game.rnd.integerInRange(100,200);
    this.onIsland = false;
    this.noClick = false;
    this.tween;
    
    this.x = game.rnd.integerInRange(2,28); //28
    this.y = game.rnd.integerInRange(2,28);
    this.checkTile = function(){
        if (mapArray[this.x][this.y] == 0){
            mapArray[this.x][this.y] = 4; 
            this.onIsland = false;
        }else{this.onIsland=true;}
    }
    this.checkTile();
    this.direction = game.rnd.integerInRange(1,4);
    this.wind = game.add.sprite(this.x*SCALE,this.y*SCALE,'wind');
    this.wind.animations.add('down', [0,1,2], 6);
    this.wind.animations.add('left',[3,4,5],6);
    this.wind.animations.add('up',[6,7,8],6);
    this.wind.animations.add('right',[9,10,11],6);
    if (this.direction == 1){this.wind.animations.play('left');}
    if (this.direction == 2){this.wind.animations.play('up');}
    if (this.direction == 3){this.wind.animations.play('right');}
    if (this.direction == 4){this.wind.animations.play('down');}
    this.wind.inputEnabled = true;
    this.wind.events.onInputDown.add(clickWind,this);
    
    this.destroy = function(){
        if (!this.onIsland){
            mapArray[this.x][this.y] = 0;
        }
    }
    this.update = function(){
        if (this.direction == 1){this.wind.animations.play('left');}
        if (this.direction == 2){this.wind.animations.play('up');}
        if (this.direction == 3){this.wind.animations.play('right');}
        if (this.direction == 4){this.wind.animations.play('down');}
        this.move();
    }
    this.moved = function(){
        this.noClick = false;
    }
    this.move = function(){
        if (game.rnd.integerInRange(1,1000) <= 1){
            if (this.direction == 1 && this.x >= 1){
                this.noClick = true;
                this.tween = game.add.tween(this.wind).to({x: (this.x -1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
                this.tween.onComplete.add(this.moved, this);
                if (!this.onIsland){mapArray[this.x][this.y] == 0}
                this.x -= 1;
                this.checkTile();
            }else if(this.x <1 && this.direction == 1){
                this.destroy()
                this.wind.destroy()
                windArray.splice(this.index,1);
            }
            else if (this.direction == 2 && this.y >= 1){
                this.noClick = true;
                this.tween = game.add.tween(this.wind).to({y: (this.y -1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
                this.tween.onComplete.add(this.moved, this);
                if (!this.onIsland){mapArray[this.x][this.y] == 0}
                this.y -= 1;
                this.checkTile();
            }else if(this.y <1 && this.direction ==2){
                this.destroy()
                this.wind.destroy()
                windArray.splice(this.index,1);
            }
            else if (this.direction == 3 && this.x <= 28){
                this.noClick = true;
                this.tween = game.add.tween(this.wind).to({x: (this.x +1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
                this.tween.onComplete.add(this.moved, this);
                if (!this.onIsland){mapArray[this.x][this.y] == 0}
                this.x += 1;
                this.checkTile();
            }else if(this.x >28 && this.direction == 3){
                this.destroy()
                this.wind.destroy()
                windArray.splice(this.index,1);
            }
            else if (this.direction == 4 && this.y <= 28){
                this.noClick = true;
                this.tween = game.add.tween(this.wind).to({y: (this.y +1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
                this.tween.onComplete.add(this.moved, this);
                if (!this.onIsland){mapArray[this.x][this.y] == 0}
                this.y += 1;
                this.checkTile();
            }else if(this.y >28 && this.direction == 4){
                this.destroy()
                this.wind.destroy()
                windArray.splice(this.index,1);
            }
        }
    }
    
    this.getDirection = function(){
        return this.direction;
    }
    this.clickWind = function(){
        
    }
}

function clickWind(){
    if (!this.noClick){
        this.direction += 1; if (this.direction > 4){this.direction = 1;}
    }
}
    
Debris = function (index, game){
    
    this.index = index;
    this.game = game;
    this.speed = game.rnd.integerInRange(700,1000);
    this.onIsland = false;
    this.tween;
    this.direction = 0;
    this.canMove = true;
    this.timer;
    this.type = '';
    var side = game.rnd.integerInRange(1,4);//pick a side from which to spawn
    if (side == 1){//left
        this.x = 0;
        this.y = game.rnd.integerInRange(0,29);
        this.direction = game.rnd.integerInRange(1,4);
        if(this.direction == 1){this.direction = 3;}
    }else if (side == 2){//Top
        this.x = game.rnd.integerInRange(0,29);
        this.y = 0;
        this.direction = game.rnd.integerInRange(1,4);
        if(this.direction == 2){this.direction = 4;}
    }else if (side == 3){//Right
        this.x = 29;
        this.y = game.rnd.integerInRange(0,29);
        this.direction = game.rnd.integerInRange(1,4);
        if(this.direction == 3){this.direction = 4;}
    }else if (side == 4){//Bottom
        this.x = game.rnd.integerInRange(0,29);
        this.y = 29;
        this.direction = game.rnd.integerInRange(1,4);
        if(this.direction == 4){this.direction = 2;}
    }
    if (game.rnd.integerInRange(1,100) <=50){
        this.debris = game.add.sprite(this.x*SCALE,this.y*SCALE,'coconut');
        this.type = 'coconut';
    }else{this.debris = game.add.sprite(this.x*SCALE,this.y*SCALE,'trash');
         this.type = 'trash';}
    this.timer = game.time.create(false);
    
    this.update = function(){
        if (this.canMove){
            //this.move();
            
        }
        
    }
    this.moved = function(){
        //Check for wind or island
        //this.timer.destroy();
        if (mapArray[this.x][this.y] == 4){ //hit Wind
            windArray.forEach(function(element){
                if(element.x == this.x && element.y == this.y){
                    this.speed -= element.speed;
                    this.direction = element.direction;
                    
                }
            })
        }else if(mapArray[this.x][this.y] == 1 || mapArray[this.x][this.y] == 5){// hit land
            plantTree(this.x,this.y, this.type);
            this.destroy();
        }
        
        this.canMove = true;
        this.move();
    }
    this.move = function(){
        this.canMove = false;
        //var tween;
        if (this.speed <= 100){this.speed = 100;}
        if(this.direction == 1 && this.x >=1){//left
            this.tween = this.game.add.tween(this.debris).to({x: (this.x - 1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
            this.tween.onComplete.add(this.moved,this);
            console.log("move left");
        }else if(this.x <1 && this.direction == 1){
            this.destroy();
        }
        else if(this.direction == 2 && this.y >=1){//up
            this.tween = this.game.add.tween(this.debris).to({y: (this.y - 1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
            this.tween.onComplete.add(this.moved,this);
            console.log("move up");
        }else if(this.y <1 && this.direction == 2){
            this.destroy();
        }
        else if(this.direction == 3 && this.x <= 28){//right
            this.tween = game.add.tween(this.debris).to({x: (this.x + 1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
            this.tween.onComplete.add(this.moved,this);
            console.log("move right");
        }else if(this.x >28 && this.direction == 3){
            this.destroy();
        }
        else if(this.direction == 4 && this.y <= 28){//down
            this.tween = game.add.tween(this.debris).to({y: (this.y + 1)*SCALE},this.speed, Phaser.Easing.Linear.None, true);
            this.tween.onComplete.add(this.moved,this);
            console.log("move down");
        }else if(this.y >28 && this.direction == 4){
            this.destroy();
        }
        //this.timer = game.time.create(false);
        //this.timer.loop(1000, function() {this.moved();}, this);
        //this.timer.start();
    }
    this.destroy = function(){
        this.debris.destroy();
        debrisArray.splice(this.index,1);
    }
    
}

function plantTree(x,y,type){
    if (mapArray[x][y] == 1){//plant tree here
        if (type == 'coconut'){
            mapArray[x][y] == 5;
            treeArray[treeIndex] = game.add.sprite(x*SCALE,y*SCALE, 'tree');
            treeIndex ++;
        }else if (type == 'trash'){
            mapArray[x][y] == 6;
            trashArray[trashIndex] = game.add.sprite(x*SCALE,y*SCALE, 'trashPile');
            trashIndex ++;
        }
    }else if(mapArray[x][y] == 5){//plant tree in an adjacent square
        if(mapArray[x-1][y] == 1){//plant tree on left tile
            mapArray[x-1][y] == 5;
            treeArray[treeIndex] = game.add.sprite((x-1)*SCALE,y*SCALE);
            treeIndex ++;
        }else if(mapArray[x][y-1] == 1){//plant tree above
            mapArray[x][y-1] == 5;
            treeArray[treeIndex] = game.add.sprite(x*SCALE,(y-1)*SCALE);
            treeIndex ++;
        }else if(mapArray[x+1][y] == 1){//plant tree on right tile
            mapArray[x+1][y] == 5;
            treeArray[treeIndex] = game.add.sprite((x+1)*SCALE,y*SCALE);
            treeIndex ++;
        }else if(mapArray[x][y+1] == 1){//plant tree below
            mapArray[x][y+1] == 5;
            treeArray[treeIndex] = game.add.sprite(x*SCALE,(y+1)*SCALE);
            treeIndex ++;
        }
    }
}
    /////////////////////////////////
//////////////END PHASE 2 LOGIC////////////
    ////////////////////////////////
    
/*********************************************************
borrowed code from stackoverflow for creating n-dimension array
**********************************************************/
function createArray(length) {
    var arr = new Array(length || 0),
        i = length;

    if (arguments.length > 1) {
        var args = Array.prototype.slice.call(arguments, 1);
        while(i--) arr[length-1 - i] = createArray.apply(this, args);
    }

    return arr;
}
/*********************************************************
drawing the map from an array to the data
**********************************************************/
function drawMap(){
    var data;
    for (var y = 0; y < 30; y++)
    {
        for (var x = 0; x < 30; x++)
        {
            data += mapArray[x][y];
            if (x < 29)
            {
                data += ',';
            }
        }

        if (y < 29)
        {
            data += "\n";
        }
    }
    
    
}


</script>

</body>
</html>